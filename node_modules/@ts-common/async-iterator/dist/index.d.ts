import * as sync from "@ts-common/iterator";
export declare type Entry<T> = sync.Entry<T>;
export declare type AsyncIterableEx<T> = {
    readonly fold: <A>(func: (a: A, b: T, i: number) => Promise<A> | A, init: A) => Promise<A>;
    readonly toArray: () => Promise<readonly T[]>;
    readonly entries: () => AsyncIterableEx<Entry<T>>;
    readonly map: <R>(func: (v: T, i: number) => Promise<R> | R) => AsyncIterableEx<R>;
    readonly flatMap: <R>(func: (v: T, i: number) => AsyncIterable<R>) => AsyncIterableEx<R>;
    readonly filter: (func: (v: T, i: number) => Promise<boolean> | boolean) => AsyncIterableEx<T>;
} & AsyncIterable<T>;
export declare const iterable: <T>(createIterator: () => AsyncIterator<T>) => AsyncIterableEx<T>;
export declare const fromSync: <T>(input: sync.Iterable<T>) => AsyncIterableEx<T>;
export declare const fromSequence: <T>(...a: readonly T[]) => AsyncIterableEx<T>;
export declare const fromPromise: <T>(p: Promise<sync.Iterable<T>>) => AsyncIterableEx<T>;
export declare const fold: <T, A>(input: AsyncIterable<T> | undefined, func: (a: A, b: T, i: number) => A | Promise<A>, init: A) => Promise<A>;
export declare const toArray: <T>(input: AsyncIterable<T> | undefined) => Promise<readonly T[]>;
export declare const entries: <T>(input: AsyncIterable<T> | undefined) => AsyncIterableEx<readonly [number, T]>;
export declare const map: <T, I>(input: AsyncIterable<I> | undefined, func: (v: I, i: number) => T | Promise<T>) => AsyncIterableEx<T>;
export declare const flatten: <T>(input: AsyncIterable<AsyncIterable<T> | undefined> | undefined) => AsyncIterableEx<T>;
export declare const flatMap: <T, I>(input: AsyncIterable<I> | undefined, func: (v: I, i: number) => AsyncIterable<T> | undefined) => AsyncIterableEx<T>;
export declare const empty: <T>() => AsyncIterableEx<T>;
export declare const filter: <T>(input: AsyncIterable<T> | undefined, func: (v: T, i: number) => boolean | Promise<boolean>) => AsyncIterableEx<T>;
//# sourceMappingURL=index.d.ts.map