"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fsp = tslib_1.__importStar(require("@ts-common/fs"));
const it = tslib_1.__importStar(require("@ts-common/iterator"));
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const path = tslib_1.__importStar(require("path"));
const async_retry_1 = tslib_1.__importDefault(require("async-retry"));
const protocolSeparator = "://";
const toUrlString = (url) => url.protocol + protocolSeparator + url.path;
exports.urlParse = (dir) => {
    const split = dir.split(protocolSeparator);
    return split.length === 2
        ? {
            protocol: split[0],
            path: split[1]
        }
        : undefined;
};
exports.readFile = async (pathStr) => {
    const result = exports.urlParse(pathStr);
    return result === undefined
        ? (await fsp.readFile(pathStr)).toString()
        : await getByUrl(pathStr);
};
const getByUrl = async (url) => {
    return async_retry_1.default(async (bail, retryNr) => {
        try {
            const response = await node_fetch_1.default(url);
            const body = await response.text();
            if (response.status !== 200) {
                const msg = `StatusCode: "${response.status}", ResponseBody: "${body}."`;
                bail(new Error(msg));
            }
            return body;
        }
        catch (fetchError) {
            const message = `Request to ${url} failed with error ${fetchError} on retry number ${retryNr}.`;
            throw new Error(message);
        }
    }, {
        retries: 3,
        factor: 1
    });
};
exports.pathResolve = (dir) => exports.urlParse(dir) !== undefined ? dir : path.resolve(dir);
exports.pathJoin = (dir, value) => {
    const url = exports.urlParse(dir);
    return url !== undefined
        ? toUrlString({
            protocol: url.protocol,
            path: url.path.split("/").concat([value]).join("/")
        })
        : path.join(dir, value);
};
const IsStatusCodeRetryable = (statusCode) => {
    if (statusCode >= 500 || statusCode === 408 || statusCode === 407) {
        return true;
    }
    return false;
};
exports.exists = async (dir) => {
    if (exports.urlParse(dir) !== undefined) {
        let retries = 0;
        const retryTimes = 3;
        const retryIntervals = [1000, 3000, 7000];
        while (retries < retryTimes) {
            try {
                const { status } = await node_fetch_1.default(dir, {
                    method: "HEAD",
                    timeout: 60 * 1000
                });
                if (status === 200) {
                    return true;
                }
                else if (!IsStatusCodeRetryable(status) || retries === retryTimes) {
                    break;
                }
                await new Promise(r => setTimeout(r, retryIntervals[retries++]));
            }
            catch (e) {
                if (retries === retryTimes) {
                    throw new Error(e.message);
                }
                await new Promise(r => setTimeout(r, retryIntervals[retries++]));
            }
        }
        return false;
    }
    else {
        return fsp.exists(dir);
    }
};
exports.pathDirName = (dir) => {
    const url = exports.urlParse(dir);
    if (url === undefined) {
        return path.dirname(dir);
    }
    const split = url.path.split("/");
    return toUrlString({
        protocol: url.protocol,
        path: split.length <= 1 ? url.path : it.join(it.dropRight(split), "/")
    });
};
//# sourceMappingURL=index.js.map