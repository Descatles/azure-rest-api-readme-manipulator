"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.iterable = (createIterator) => {
    const it = { [Symbol.iterator]: createIterator };
    const property = (f) => (...p) => f(it, ...p);
    return {
        [Symbol.iterator]: createIterator,
        concat: property(exports.concat),
        drop: property(exports.drop),
        entries: property(exports.entries),
        every: property(exports.every),
        filter: property(exports.filter),
        filterMap: property(exports.filterMap),
        find: property(exports.find),
        findEntry: property(exports.findEntry),
        flatMap: property(exports.flatMap),
        fold: property(exports.fold),
        forEach: property(exports.forEach),
        isEmpty: property(exports.isEmpty),
        isEqual: property(exports.isEqual),
        last: property(exports.last),
        map: property(exports.map),
        reduce: property(exports.reduce),
        reverse: property(exports.reverse),
        some: property(exports.some),
        take: property(exports.take),
        takeWhile: property(exports.takeWhile),
        toArray: property(exports.toArray),
        uniq: property(exports.uniq),
        zip: property(exports.zip),
        scan: property(exports.scan),
        flatScan: property(exports.flatScan),
        first: property(exports.first)
    };
};
exports.ENTRY_KEY = 0;
exports.ENTRY_VALUE = 1;
exports.chain = (input) => exports.iterable(() => input[Symbol.iterator]());
exports.entries = (input) => exports.iterable(function* () {
    // tslint:disable-next-line:no-if-statement
    if (input === undefined) {
        return;
    }
    let index = 0;
    // tslint:disable-next-line:no-loop-statement
    for (const value of input) {
        yield [index, value];
        // tslint:disable-next-line:no-expression-statement
        index += 1;
    }
});
exports.map = (input, func) => exports.iterable(function* () {
    // tslint:disable-next-line:no-loop-statement
    for (const [index, value] of exports.entries(input)) {
        yield func(value, index);
    }
});
exports.drop = (input, n = 1) => exports.filter(input, (_, i) => n <= i);
exports.flat = (input) => exports.iterable(function* () {
    // tslint:disable-next-line:no-if-statement
    if (input === undefined) {
        return;
    }
    // tslint:disable-next-line:no-loop-statement
    for (const v of input) {
        // tslint:disable-next-line:no-if-statement
        if (v !== undefined) {
            yield* v;
        }
    }
});
exports.concat = (...input) => exports.flat(input);
exports.takeWhile = (input, func) => exports.iterable(function* () {
    // tslint:disable-next-line:no-loop-statement
    for (const [index, value] of exports.entries(input)) {
        // tslint:disable-next-line:no-if-statement
        if (!func(value, index)) {
            return;
        }
        yield value;
    }
});
exports.take = (input, n = 1) => exports.takeWhile(input, (_, i) => i < n);
exports.findEntry = (input, func) => {
    // tslint:disable-next-line:no-loop-statement
    for (const e of exports.entries(input)) {
        // tslint:disable-next-line:no-if-statement
        if (func(e[exports.ENTRY_VALUE], e[exports.ENTRY_KEY])) {
            return e;
        }
    }
    return undefined;
};
exports.find = (input, func) => {
    const e = exports.findEntry(input, func);
    return e === undefined ? undefined : e[exports.ENTRY_VALUE];
};
exports.flatMap = (input, func) => exports.flat(exports.map(input, func));
exports.optionalToArray = (v) => v === undefined ? [] : [v];
exports.filterMap = (input, func) => exports.flatMap(input, (v, i) => exports.optionalToArray(func(v, i)));
exports.filter = (input, func) => exports.flatMap(input, (v, i) => func(v, i) ? [v] : []);
const infinite = () => exports.iterable(function* () {
    // tslint:disable-next-line:no-loop-statement
    while (true) {
        yield;
    }
});
exports.generate = (func, count) => infinite()
    .takeWhile((_, i) => i !== count)
    .map((_, i) => func(i));
exports.repeat = (v, count) => exports.generate(() => v, count);
exports.scan = (input, func, init) => exports.iterable(function* () {
    let result = init;
    yield result;
    // tslint:disable-next-line:no-loop-statement
    for (const [index, value] of exports.entries(input)) {
        // tslint:disable-next-line:no-expression-statement
        result = func(result, value, index);
        yield result;
    }
});
exports.flatScan = (input, func, init) => exports.iterable(function* () {
    let state = init;
    // tslint:disable-next-line:no-loop-statement
    for (const [index, value] of exports.entries(input)) {
        // tslint:disable-next-line:no-expression-statement
        const [newState, result] = func(state, value, index);
        // tslint:disable-next-line:no-expression-statement
        state = newState;
        yield* result;
    }
});
exports.fold = (input, func, init) => {
    let result = init;
    // tslint:disable-next-line:no-loop-statement
    for (const [index, value] of exports.entries(input)) {
        // tslint:disable-next-line:no-expression-statement
        result = func(result, value, index);
    }
    return result;
};
exports.reduce = (input, func) => exports.fold(input, (a, b, i) => a !== undefined ? func(a, b, i) : b, undefined);
exports.first = (input) => {
    // tslint:disable-next-line:no-if-statement
    if (input !== undefined) {
        // tslint:disable-next-line:no-loop-statement
        for (const v of input) {
            return v;
        }
    }
    return undefined;
};
exports.last = (input) => exports.reduce(input, (_, v) => v);
exports.some = (input, func = () => true) => exports.findEntry(input, func) !== undefined;
exports.every = (input, func) => !exports.some(input, (v, i) => !func(v, i));
exports.forEach = (input, func) => {
    // tslint:disable-next-line:no-expression-statement
    exports.fold(input, (_, v, i) => { func(v, i); }, undefined);
};
exports.sum = (input) => exports.fold(input, (a, b) => a + b, 0);
exports.min = (input) => exports.fold(input, (a, b) => Math.min(a, b), Infinity);
exports.max = (input) => exports.fold(input, (a, b) => Math.max(a, b), -Infinity);
exports.zip = (...inputs) => exports.iterable(function* () {
    const iterators = inputs.map(i => i === undefined ? [][Symbol.iterator]() : i[Symbol.iterator]());
    // tslint:disable-next-line:no-loop-statement
    while (true) {
        const result = new Array(inputs.length);
        // tslint:disable-next-line:no-loop-statement
        for (const [index, it] of exports.entries(iterators)) {
            const v = it.next();
            // tslint:disable-next-line:no-if-statement
            if (v.done) {
                return;
            }
            // tslint:disable-next-line:no-object-mutation no-expression-statement
            result[index] = v.value;
        }
        yield result;
    }
});
// TypeScript gives an error in case if type of a and type of b are different
exports.isStrictEqual = (a, b) => a === b;
exports.isEqual = (a, b, e = exports.isStrictEqual) => {
    // tslint:disable-next-line:no-if-statement
    if (exports.isStrictEqual(a, b)) {
        return true;
    }
    // tslint:disable-next-line:no-if-statement
    if (a === undefined || b === undefined) {
        return false;
    }
    const ai = a[Symbol.iterator]();
    const bi = b[Symbol.iterator]();
    // tslint:disable-next-line:no-loop-statement
    while (true) {
        const av = ai.next();
        const bv = bi.next();
        // tslint:disable-next-line:no-if-statement
        if (av.done || bv.done) {
            return av.done === bv.done;
        }
        // tslint:disable-next-line:no-if-statement
        if (!e(av.value, bv.value)) {
            return false;
        }
    }
};
exports.isArray = (v) => v instanceof Array;
exports.toArray = (i) => i === undefined ? [] : Array.from(i);
exports.reverse = (i) => exports.fold(i, (a, b) => [b, ...a], new Array());
exports.arrayReverse = (a) => exports.iterable(function* () {
    // tslint:disable-next-line:no-loop-statement
    for (let i = a.length; i > 0;) {
        // tslint:disable-next-line:no-expression-statement
        i -= 1;
        yield a[i];
    }
});
exports.isEmpty = (i) => !exports.some(i, () => true);
exports.join = (i, separator) => {
    const result = exports.reduce(i, (a, b) => a + separator + b);
    return result === undefined ? "" : result;
};
// tslint:disable-next-line:no-empty
exports.empty = () => exports.iterable(function* () { });
exports.dropRight = (i, n = 1) => i === undefined ? exports.empty() : exports.take(i, i.length - n);
exports.uniq = (i, key = v => v) => exports.flatScan(i, (set, v) => {
    const k = key(v);
    // tslint:disable-next-line:no-if-statement
    if (!set.has(k)) {
        // tslint:disable-next-line:no-expression-statement
        set.add(k);
        return [set, [v]];
    }
    return [set, []];
}, new Set());
//# sourceMappingURL=index.js.map