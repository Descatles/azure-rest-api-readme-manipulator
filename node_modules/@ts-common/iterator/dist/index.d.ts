/**
 * See this PR https://github.com/microsoft/TypeScript/pull/30790
 */
export declare type IteratorResult<T> = {
    /**
     * - Has the value `true` if the iterator is past the end of the iterated sequence. In this case value optionally
     *   specifies the return value of the iterator.
     * - Has the value `false` if the iterator was able to produce the next value in the sequence. This is equivalent of
     *   not specifying the done property altogether.
     */
    readonly done: boolean;
    /**
     * any JavaScript value returned by the iterator. Can be omitted when done is true.
     */
    readonly value: T;
};
export declare type Iterator<T> = {
    /**
     * Returns `IterableResult<T>`.
     */
    readonly next: () => IteratorResult<T>;
};
export declare type Iterable<T> = {
    /**
     * The function returns an iterator.
     */
    readonly [Symbol.iterator]: () => Iterator<T>;
};
export declare type IterableEx<T> = Iterable<T> & {
    /**
     * The function returns an iterator of a this container own enumerable number-keyed value [key, value] pairs.
     */
    readonly entries: () => IterableEx<Entry<T>>;
    /**
     * Creates a new sequence whose values are calculated by passing this sequence's elements through the given
     * function.
     */
    readonly map: <R>(func: (v: T, i: number) => R) => IterableEx<R>;
    /**
     *  Returns the first element of this sequence or `undefined` if the sequence is empty.
     */
    readonly first: () => T | undefined;
    /**
     * The flatMap() method first maps each element using a mapping function, then flattens the result.
     */
    readonly flatMap: <R>(func: (v: T, i: number) => Iterable<R>) => IterableEx<R>;
    /**
     * Creates a new sequence whose values are the elements of this sequence which satisfy the specified predicate.
     */
    readonly filter: (func: (v: T, i: number) => boolean) => IterableEx<T>;
    /**
     * Creates a new sequence whose values are calculated by passing this sequence's elements through the given
     * function. If the function `func` returns `undefined`, the item is removed from the sequence.
     */
    readonly filterMap: <R>(func: (v: T, i: number) => R | undefined) => IterableEx<R>;
    /**
     * The forEach() method executes a provided function once for each sequence element.
     */
    readonly forEach: (func: (v: T, i: number) => void) => void;
    /**
     * Creates a slice of sequence with n elements dropped from the beginning.
     */
    readonly drop: (n?: number) => IterableEx<T>;
    /**
     * Creates a new sequence with all of the elements of this one, plus those of the given sequence(s).
     */
    readonly concat: (...input: readonly (Iterable<T> | undefined)[]) => IterableEx<T>;
    /**
     * Creates a new sequence comprising the elements from the head of this sequence that satisfy some predicate. Once
     * an element is encountered that doesn't satisfy the predicate, iteration will stop.
     */
    readonly takeWhile: (func: (v: T, i: number) => boolean) => IterableEx<T>;
    /**
     * Creates a slice of sequence with n elements taken from the beginning.
     */
    readonly take: (n?: number) => IterableEx<T>;
    /**
     * This method is like find except that it returns the `Entry<T>` of the first element predicate returns truthy for
     * instead of the element itself. This is useful if the sequence can contain `undefined` values.
     */
    readonly findEntry: (func: (v: T, i: number) => boolean) => Entry<T> | undefined;
    /**
     * Searches for the first element in the sequence satisfying a given predicate.
     */
    readonly find: (func: (v: T, i: number) => boolean) => T | undefined;
    /**
     * Reduces collection to a value which is the accumulated result of running each element in collection thru
     * `func`, where each successive invocation is supplied the return value of the previous.
     */
    readonly fold: <A>(func: (a: A, b: T, i: number) => A, init: A) => A;
    /**
     * Reduces collection to a value which is the accumulated result of running each element in collection thru
     * `func`, where each successive invocation is supplied the return value of the previous.
     *
     * The first element of collection is used as the initial value.
     */
    readonly reduce: (func: (a: T, b: T, i: number) => T) => T | undefined;
    /**
     *  Returns the last element of this sequence or `undefined` if the sequence is empty.
     */
    readonly last: () => T | undefined;
    /**
     * Checks whether at least one element in this sequence satisfies a given predicate (or, if no predicate is
     * specified, whether the sequence contains at least one element).
     */
    readonly some: (func?: (v: T, i: number) => boolean) => boolean;
    /**
     * Checks whether every element in this sequence satisfies a given predicate.
     */
    readonly every: (func: (v: T, i: number) => boolean) => boolean;
    /**
     * Creates a new sequence by combining the elements from this sequence with corresponding elements from the
     * specified sequence(s).
     */
    readonly zip: (...inputs: readonly (Iterable<T> | undefined)[]) => IterableEx<readonly T[]>;
    /**
     * Checks if all items in the sequence are equal to the items in the given sequence `b`.
     */
    readonly isEqual: <B>(b: Iterable<B> | undefined, e?: (ai: T, bi: B) => boolean) => boolean;
    /**
     * Creates an array snapshot of a sequence.
     */
    readonly toArray: () => readonly T[];
    /**
     * Creates a new array with the same elements as this sequence, but in the opposite order.
     */
    readonly reverse: () => readonly T[];
    /**
     * Checks whether the sequence has no elements.
     */
    readonly isEmpty: () => boolean;
    /**
     * Creates a new sequence with every unique element from this one appearing exactly once (i.e., with duplicates
     * removed).
     */
    readonly uniq: (key?: (v: T) => unknown) => IterableEx<T>;
    /**
     * Creates a new sequence of accumulated values. It's exclusive scan so it always returns at least one value.
     */
    readonly scan: <A>(func: (a: A, b: T, i: number) => A, init: A) => IterableEx<A>;
    /**
     * Firstly, the function maps a state and each element using the `func` function, then flattens the result.
     */
    readonly flatScan: <A, R>(func: (a: A, b: T, i: number) => readonly [A, Iterable<R>], init: A) => IterableEx<R>;
};
export declare const iterable: <T>(createIterator: () => Iterator<T>) => IterableEx<T>;
export declare type Entry<T> = readonly [number, T];
export declare const ENTRY_KEY = 0;
export declare const ENTRY_VALUE = 1;
export declare const chain: <T>(input: readonly T[]) => IterableEx<T>;
export declare const entries: <T>(input: Iterable<T> | undefined) => IterableEx<readonly [number, T]>;
export declare const map: <T, I>(input: Iterable<I> | undefined, func: (v: I, i: number) => T) => IterableEx<T>;
export declare const drop: <T>(input: Iterable<T> | undefined, n?: number) => IterableEx<T>;
export declare const flat: <T>(input: Iterable<Iterable<T> | undefined> | undefined) => IterableEx<T>;
export declare const concat: <T>(...input: readonly (Iterable<T> | undefined)[]) => IterableEx<T>;
export declare const takeWhile: <T>(input: Iterable<T> | undefined, func: (v: T, i: number) => boolean) => IterableEx<T>;
export declare const take: <T>(input: Iterable<T> | undefined, n?: number) => IterableEx<T>;
export declare const findEntry: <T>(input: Iterable<T> | undefined, func: (v: T, i: number) => boolean) => readonly [number, T] | undefined;
export declare const find: <T>(input: Iterable<T> | undefined, func: (v: T, i: number) => boolean) => T | undefined;
export declare const flatMap: <T, I>(input: Iterable<I> | undefined, func: (v: I, i: number) => Iterable<T>) => IterableEx<T>;
export declare const optionalToArray: <T>(v: T | undefined) => readonly T[];
export declare const filterMap: <T, I>(input: Iterable<I> | undefined, func: (v: I, i: number) => T | undefined) => IterableEx<T>;
export declare const filter: <T>(input: Iterable<T> | undefined, func: (v: T, i: number) => boolean) => IterableEx<T>;
export declare const generate: <T>(func: (i: number) => T, count?: number | undefined) => IterableEx<T>;
export declare const repeat: <T>(v: T, count?: number | undefined) => IterableEx<T>;
export declare const scan: <T, A>(input: Iterable<T> | undefined, func: (a: A, b: T, i: number) => A, init: A) => IterableEx<A>;
export declare const flatScan: <T, A, R>(input: Iterable<T> | undefined, func: (a: A, b: T, i: number) => readonly [A, Iterable<R>], init: A) => IterableEx<R>;
export declare const fold: <T, A>(input: Iterable<T> | undefined, func: (a: A, b: T, i: number) => A, init: A) => A;
export declare const reduce: <T>(input: Iterable<T> | undefined, func: (a: T, b: T, i: number) => T) => T | undefined;
export declare const first: <T>(input: Iterable<T> | undefined) => T | undefined;
export declare const last: <T>(input: Iterable<T> | undefined) => T | undefined;
export declare const some: <T>(input: Iterable<T> | undefined, func?: (v: T, i: number) => boolean) => boolean;
export declare const every: <T>(input: Iterable<T> | undefined, func: (v: T, i: number) => boolean) => boolean;
export declare const forEach: <T>(input: Iterable<T> | undefined, func: (v: T, i: number) => void) => void;
export declare const sum: (input: Iterable<number> | undefined) => number;
export declare const min: (input: Iterable<number> | undefined) => number;
export declare const max: (input: Iterable<number> | undefined) => number;
export declare const zip: <T>(...inputs: readonly (Iterable<T> | undefined)[]) => IterableEx<readonly T[]>;
export declare const isStrictEqual: (a: unknown, b: unknown) => boolean;
export declare const isEqual: <A, B>(a: Iterable<A> | undefined, b: Iterable<B> | undefined, e?: (ai: A, bi: B) => boolean) => boolean;
export declare const isArray: <T, U>(v: U | readonly T[]) => v is readonly T[];
export declare const toArray: <T>(i: Iterable<T> | undefined) => readonly T[];
export declare const reverse: <T>(i: Iterable<T> | undefined) => readonly T[];
export declare const arrayReverse: <T>(a: readonly T[]) => IterableEx<T>;
export declare const isEmpty: <T>(i: Iterable<T> | undefined) => boolean;
export declare const join: (i: Iterable<string> | undefined, separator: string) => string;
export declare const empty: <T>() => IterableEx<T>;
export declare const dropRight: <T>(i: readonly T[] | undefined, n?: number) => IterableEx<T>;
export declare const uniq: <T>(i: Iterable<T>, key?: (v: T) => unknown) => IterableEx<T>;
//# sourceMappingURL=index.d.ts.map