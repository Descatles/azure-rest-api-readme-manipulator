"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const yaml = tslib_1.__importStar(require("js-yaml"));
const gitHubUtils_1 = require("./gitHubUtils");
const commonmark_to_markdown_1 = require("@ts-common/commonmark-to-markdown");
const sm = tslib_1.__importStar(require("@ts-common/string-map"));
const it = tslib_1.__importStar(require("@ts-common/iterator"));
exports.inputFile = (tagSettings) => {
    const f = tagSettings["input-file"];
    return typeof f === "string" ? [f] : f;
};
/**
 * Provides operations that can be applied to readme files
 */
class ReadMeManipulator {
    constructor(logger, readMeBuilder) {
        this.logger = logger;
        this.readMeBuilder = readMeBuilder;
        /**
         * Updates the latest version tag of a readme
         */
        this.updateLatestTag = (markDownEx, newTag) => {
            const startNode = markDownEx.markDown;
            const codeBlockMap = exports.getCodeBlocksAndHeadings(startNode);
            const latestHeader = "Basic Information";
            const lh = codeBlockMap[latestHeader];
            if (lh === undefined) {
                this.logger.error(`Couldn't parse code block`);
                throw new Error("");
            }
            const latestDefinition = yaml.load(lh.literal);
            if (!latestDefinition) {
                this.logger.error(`Couldn't parse code block`);
                throw new Error("");
            }
            latestDefinition.tag = newTag;
            lh.literal = yaml.dump(latestDefinition, {
                lineWidth: -1
            });
            return commonmark_to_markdown_1.markDownExToString(markDownEx);
        };
        this.insertTagDefinition = (readmeContent, tagFiles, newTag) => {
            const newTagDefinitionYaml = createTagDefinitionYaml(tagFiles);
            const toSplice = this.readMeBuilder.getVersionDefinition(newTagDefinitionYaml, newTag);
            return spliceIntoTopOfVersions(readmeContent, toSplice);
        };
        this.addSuppressionBlock = (readme) => `${readme}\n\n${this.readMeBuilder.getSuppressionSection()}`;
        /**
         * This function takes a markdown document and a list of file paths and
         * returns the list of tags that reference these file paths. It is meant to
         * work like https://github.com/Azure/azure-rest-api-specs/blob/master/test/linter.js
         */
        this.getTagsForFilesChanged = (markDownEx, specsChanged) => {
            const codeBlocks = exports.getTagsToSettingsMapping(markDownEx.markDown);
            const tagsAffected = new Set();
            for (const [tag, settings] of sm.entries(codeBlocks)) {
                // for every file in settings object, see if it matches one of the
                // paths changed
                const filesTouchedInTag = specsChanged.filter(spec => exports.inputFile(settings).some(inputFile => spec.includes(inputFile)));
                if (filesTouchedInTag.length > 0) {
                    tagsAffected.add(tag);
                }
            }
            return [...tagsAffected];
        };
        this.getAllTags = (markDownEx) => {
            const codeBlocks = exports.getTagsToSettingsMapping(markDownEx.markDown);
            const tags = new Set();
            for (const [tag] of sm.entries(codeBlocks)) {
                tags.add(tag);
            }
            return [...tags];
        };
    }
}
exports.ReadMeManipulator = ReadMeManipulator;
const isTagSettings = (obj) => typeof obj === "object" &&
    obj !== null &&
    "input-file" in obj;
exports.getTagsToSettingsMapping = (startNode) => getAllCodeBlockNodes(startNode).fold((accumulator, node) => {
    if (node && node.literal && node.info) {
        let settings;
        try {
            settings = yaml.safeLoad(node.literal, {});
        }
        catch (e) {
            return accumulator;
        }
        // tag matching from
        // https://github.com/Azure/azure-rest-api-specs/blob/45e82e67d42ee347edbdb8b15807473b5aaf3a06/test/linter.js#L37
        const matchTag = /\$\(tag\)[^'"]*(?:['"](.*?)['"])/;
        const matches = matchTag.exec(node.info);
        if (isTagSettings(settings) && matches) {
            const [, tag] = matches;
            return Object.assign({}, accumulator, { [tag]: settings });
        }
    }
    return accumulator;
}, {});
exports.getInputFiles = (startNode) => sm.values(exports.getTagsToSettingsMapping(startNode)).flatMap(exports.inputFile);
/**
 * Get input files listed for a given tag
 * @returns array of file path or null if the tag doesn't exists
 */
exports.getInputFilesForTag = (startNode, tag) => {
    const tagMapping = exports.getTagsToSettingsMapping(startNode);
    const foo = tagMapping[tag];
    return foo !== undefined ? exports.inputFile(foo) : undefined;
};
exports.addSuppression = (startNode, item) => {
    const mapping = exports.getCodeBlocksAndHeadings(startNode);
    const suppressionNode = mapping.Suppression;
    if (suppressionNode === undefined) {
        // probably it's a bug
        return;
    }
    const suppressionBlock = exports.getYamlFromNode(suppressionNode);
    const updatedSuppressionBlock = Object.assign({}, suppressionBlock, { directive: [...suppressionBlock.directive, item] });
    updateYamlForNode(suppressionNode, updatedSuppressionBlock);
};
exports.base64ToMarkDownEx = (base) => {
    const str = gitHubUtils_1.base64ToString(base);
    return commonmark_to_markdown_1.parse(str);
};
exports.getYamlFromNode = (node) => {
    const infoYaml = yaml.load(node.literal);
    return infoYaml;
};
const updateYamlForNode = (node, yamlObject) => {
    node.literal = yaml.dump(yamlObject, { lineWidth: -1 });
};
const spliceIntoTopOfVersions = (file, splice) => {
    const index = file.indexOf("### Tag");
    return file.slice(0, index) + splice + file.slice(index);
};
const createTagDefinitionYaml = (files) => ({
    ["input-file"]: files
});
exports.hasSuppressionBlock = (startNode) => {
    const mapping = exports.getCodeBlocksAndHeadings(startNode);
    return !!mapping.Suppression;
};
exports.getCodeBlocksAndHeadings = (startNode) => getAllCodeBlockNodes(startNode).fold((acc, curr) => {
    const headingNode = nodeHeading(curr);
    if (!headingNode) {
        return Object.assign({}, acc);
    }
    const headingLiteral = getHeadingLiteral(headingNode);
    if (!headingLiteral) {
        return Object.assign({}, acc);
    }
    return Object.assign({}, acc, { [headingLiteral]: curr });
}, {});
const getHeadingLiteral = (heading) => {
    const headingNode = walkToNode(heading.walker(), n => n.type === "text");
    return headingNode && headingNode.literal ? headingNode.literal : "";
};
const getAllCodeBlockNodes = (startNode) => it.iterable(function* () {
    const walker = startNode.walker();
    while (true) {
        const a = walkToNode(walker, n => n.type === "code_block");
        if (!a) {
            break;
        }
        yield a;
    }
});
const nodeHeading = (startNode) => {
    let resultNode = startNode;
    while (resultNode != null && resultNode.type !== "heading") {
        resultNode = resultNode.prev || resultNode.parent;
    }
    return resultNode;
};
/**
 * walks a markdown tree until the callback provided returns true for a node
 */
const walkToNode = (walker, cb) => {
    let event = walker.next();
    while (event) {
        const curNode = event.node;
        if (cb(curNode)) {
            return curNode;
        }
        event = walker.next();
    }
    return undefined;
};
//# sourceMappingURL=readMeManipulator.js.map