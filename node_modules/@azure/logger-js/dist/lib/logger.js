"use strict";
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
function addPrefix(text, prefix) {
    text = toArray(text);
    var prefixText = typeof prefix === "string" ? prefix : prefix();
    if (prefixText) {
        text = text.map(function (textElement) { return "" + prefixText + textElement; });
    }
    return text;
}
/**
 * Add the provided prefix to each message logged through the resulting Logger.
 * @param toWrap The Logger to wrap.
 * @param prefix The prefix to add to each log message.
 */
function prefix(toWrap, prefix) {
    return {
        logInfo: function (text) { return toWrap.logInfo(addPrefix(text, prefix)); },
        logError: function (text) { return toWrap.logError(addPrefix(text, prefix)); },
        logWarning: function (text) { return toWrap.logWarning(addPrefix(text, prefix)); },
        logSection: function (text) { return toWrap.logSection(addPrefix(text, prefix)); },
        logVerbose: function (text) { return toWrap.logVerbose(addPrefix(text, prefix)); },
    };
}
exports.prefix = prefix;
/**
 * Indent the messages logged by the resulting Logger.
 * @param toWrap The Logger to wrap.
 * @param indentation The indentation to add to the Logger's messages.
 */
function indent(toWrap, indentation) {
    if (indentation == undefined) {
        indentation = "  ";
    }
    else if (typeof indentation === "number") {
        var spaceCount = indentation;
        indentation = "";
        for (var i = 0; i < spaceCount; ++i) {
            indentation += " ";
        }
    }
    return prefix(toWrap, indentation);
}
exports.indent = indent;
/**
 * Get a logger that will log to each of the provided loggers when it is logged to.
 * @param loggers The loggers to log to.
 */
function getCompositeLogger() {
    var loggers = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        loggers[_i] = arguments[_i];
    }
    var result;
    var definedLoggers = loggers.filter(function (logger) { return !!logger; });
    if (definedLoggers.length === 1) {
        result = definedLoggers[0];
    }
    else {
        result = {
            logInfo: function (text) { return Promise.all(definedLoggers.map(function (logger) { return logger.logInfo(text); })); },
            logError: function (text) { return Promise.all(definedLoggers.map(function (logger) { return logger.logError(text); })); },
            logWarning: function (text) { return Promise.all(definedLoggers.map(function (logger) { return logger.logWarning(text); })); },
            logSection: function (text) { return Promise.all(definedLoggers.map(function (logger) { return logger.logSection(text); })); },
            logVerbose: function (text) { return Promise.all(definedLoggers.map(function (logger) { return logger.logVerbose(text); })); }
        };
    }
    return result;
}
exports.getCompositeLogger = getCompositeLogger;
function getLogFunction(optionsFunction, normalFunction, undefinedUsesNormalFunction) {
    if (undefinedUsesNormalFunction === void 0) { undefinedUsesNormalFunction = true; }
    var result = function () { return Promise.resolve(); };
    if (optionsFunction !== false) {
        if (typeof optionsFunction === "function") {
            result = function (text) { return Promise.resolve(optionsFunction(text)); };
        }
        else if (optionsFunction !== undefined || undefinedUsesNormalFunction) {
            result = function (text) { return Promise.resolve(normalFunction(text)); };
        }
    }
    return result;
}
exports.getLogFunction = getLogFunction;
/**
 * Wrap the provided Logger with the provided options.
 * @param toWrap The Logger to wrap.
 * @param options The options that should be applied to the wrapped Logger.
 * @returns The newly created Logger that wraps the provided Logger using the provided options.
 */
function wrapLogger(toWrap, options) {
    return {
        logInfo: getLogFunction(options.logInfo, function (text) { return toWrap.logInfo(text); }),
        logError: getLogFunction(options.logError, function (text) { return toWrap.logError(text); }),
        logWarning: getLogFunction(options.logWarning, function (text) { return toWrap.logWarning(text); }),
        logSection: getLogFunction(options.logSection, function (text) { return toWrap.logSection(text); }),
        logVerbose: getLogFunction(options.logVerbose, function (text) { return toWrap.logVerbose(text); }, false)
    };
}
exports.wrapLogger = wrapLogger;
function consoleLog(text) {
    text = toArray(text);
    for (var _i = 0, text_1 = text; _i < text_1.length; _i++) {
        var textLine = text_1[_i];
        console.log(textLine);
    }
    return Promise.resolve();
}
function consoleError(text) {
    text = toArray(text);
    for (var _i = 0, text_2 = text; _i < text_2.length; _i++) {
        var textLine = text_2[_i];
        console.error(textLine);
    }
    return Promise.resolve();
}
/**
 * Get a Logger that will send its logs to the console.
 */
function getConsoleLogger(options) {
    if (options === void 0) { options = {}; }
    return wrapLogger({
        logInfo: consoleLog,
        logError: consoleError,
        logWarning: consoleLog,
        logSection: consoleLog,
        logVerbose: consoleLog
    }, options);
}
exports.getConsoleLogger = getConsoleLogger;
/**
 * Get a Logger that will store its logs in memory.
 */
function getInMemoryLogger(options) {
    if (options === void 0) { options = {}; }
    var allLogs = [];
    var infoLogs = [];
    var errorLogs = [];
    var warningLogs = [];
    var sectionLogs = [];
    var verboseLogs = [];
    return {
        allLogs: allLogs,
        infoLogs: infoLogs,
        errorLogs: errorLogs,
        warningLogs: warningLogs,
        sectionLogs: sectionLogs,
        verboseLogs: verboseLogs,
        logInfo: getLogFunction(options.logInfo, function (text) {
            allLogs.push.apply(allLogs, toArray(text));
            infoLogs.push.apply(infoLogs, toArray(text));
        }),
        logError: getLogFunction(options.logError, function (text) {
            allLogs.push.apply(allLogs, toArray(text));
            errorLogs.push.apply(errorLogs, toArray(text));
        }),
        logWarning: getLogFunction(options.logWarning, function (text) {
            allLogs.push.apply(allLogs, toArray(text));
            warningLogs.push.apply(warningLogs, toArray(text));
        }),
        logSection: getLogFunction(options.logSection, function (text) {
            allLogs.push.apply(allLogs, toArray(text));
            sectionLogs.push.apply(sectionLogs, toArray(text));
        }),
        logVerbose: getLogFunction(options.logVerbose, function (text) {
            allLogs.push.apply(allLogs, toArray(text));
            verboseLogs.push.apply(verboseLogs, toArray(text));
        }, false)
    };
}
exports.getInMemoryLogger = getInMemoryLogger;
/**
 * Get a Logger that will output prefixes for certain types of logs in the Azure DevOps environment.
 */
function getAzureDevOpsLogger(options) {
    if (options === void 0) { options = {}; }
    var innerLogger = options.toWrap || getConsoleLogger(tslib_1.__assign({}, options, { logError: ("logError" in options ? options.logError : function (text) { return Promise.resolve(console.log(text)); }) }));
    return wrapLogger(innerLogger, {
        logError: function (text) { return innerLogger.logError(addPrefix(text, "##[error]")); },
        logInfo: true,
        logSection: function (text) { return innerLogger.logSection(addPrefix(text, "##[section]")); },
        logWarning: function (text) { return innerLogger.logWarning(addPrefix(text, "##[warning]")); },
        logVerbose: true
    });
}
exports.getAzureDevOpsLogger = getAzureDevOpsLogger;
/**
 * Get the default Logger based on the command line arguments.
 * @returns The default Logger based on the command line arguments.
 */
function getDefaultLogger(options) {
    if (options === void 0) { options = {}; }
    return options.type === "devops" ? getAzureDevOpsLogger(options) : getConsoleLogger(options);
}
exports.getDefaultLogger = getDefaultLogger;
/**
 * Prefix the provided logger's logs with a UTC timestamp
 */
function timestamps(logger) {
    return prefix(logger, function () { return new Date().toISOString() + ": "; });
}
exports.timestamps = timestamps;
/**
 * Prefix the provided logger's logs with line numbers.
 */
function lineNumbers(logger, firstLineNumber) {
    if (firstLineNumber === void 0) { firstLineNumber = 1; }
    var lineNumber = firstLineNumber;
    return prefix(logger, function () { return lineNumber++ + ". "; });
}
exports.lineNumbers = lineNumbers;
function toArray(text) {
    return typeof text === "string" ? [text] : text;
}
exports.toArray = toArray;
function joinLines(text) {
    return typeof text === "string" ? text : text.join("\n");
}
exports.joinLines = joinLines;
/**
 * Get the lines of the provided text.
 * @param text The text to get the lines of.
 */
function getLines(text) {
    return text == undefined ? [] : text.split(/\r?\n/);
}
exports.getLines = getLines;
/**
 * Individually log each of the lines in the provided text using the provided log function.
 * @param text The text to split and log.
 * @param log The function that will log each of the lines of text.
 */
function logLines(text, log) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var lines, _i, _a, textLine;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (!(text != undefined)) return [3 /*break*/, 2];
                    lines = [];
                    for (_i = 0, _a = toArray(text); _i < _a.length; _i++) {
                        textLine = _a[_i];
                        lines.push.apply(lines, getLines(textLine));
                    }
                    return [4 /*yield*/, Promise.resolve(log(lines))];
                case 1:
                    _b.sent();
                    _b.label = 2;
                case 2: return [2 /*return*/];
            }
        });
    });
}
/**
 * Wrap the provided logger with logic that will split logs into individual lines before they are
 * logged.
 * @param logger The Logger to wrap.
 */
function splitLines(logger) {
    return wrapLogger(logger, {
        logError: function (text) { return logLines(text, logger.logError.bind(logger)); },
        logInfo: function (text) { return logLines(text, logger.logInfo.bind(logger)); },
        logSection: function (text) { return logLines(text, logger.logSection.bind(logger)); },
        logVerbose: function (text) { return logLines(text, logger.logVerbose.bind(logger)); },
        logWarning: function (text) { return logLines(text, logger.logWarning.bind(logger)); },
    });
}
exports.splitLines = splitLines;
//# sourceMappingURL=logger.js.map